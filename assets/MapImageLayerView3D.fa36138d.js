var Q=Object.defineProperty,S=Object.defineProperties;var $=Object.getOwnPropertyDescriptors;var b=Object.getOwnPropertySymbols;var D=Object.prototype.hasOwnProperty,G=Object.prototype.propertyIsEnumerable;var I=(r,e,t)=>e in r?Q(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,E=(r,e)=>{for(var t in e||(e={}))D.call(e,t)&&I(r,t,e[t]);if(b)for(var t of b(e))G.call(e,t)&&I(r,t,e[t]);return r},F=(r,e)=>S(r,$(e));import{M as o,O as p,gi as T,Q as A,h8 as _,b6 as q,V as u,h9 as z,b8 as H,by as L}from"./vendor.96994164.js";import{q as N}from"./DynamicLayerView3D.388be3f1.js";import{s as R,a as j}from"./drapedUtils.0bf34979.js";import{t as U,d as k}from"./popupUtils.a4899550.js";import"./projectExtentUtils.ed1cd6fc.js";import"./ImageMaterial.d82c080b.js";import"./RefreshableLayerView.8c0c21e2.js";const B=r=>{let e=class extends r{initialize(){this.exportImageParameters=new _({layer:this.layer})}destroy(){this.exportImageParameters.destroy(),this.exportImageParameters=null}get exportImageVersion(){var t;return(t=this.exportImageParameters)==null||t.commitProperty("version"),this.commitProperty("timeExtent"),(this._get("exportImageVersion")||0)+1}async fetchPopupFeatures(t,n){const{layer:y}=this;if(!t)return Promise.reject(new q("mapimagelayerview:fetchPopupFeatures","Nothing to fetch without area",{layer:y}));const d=this.get("view.scale"),h=[],g=async a=>{const i=a.minScale===0||d<=a.minScale,s=a.maxScale===0||d>=a.maxScale;if(a.visible&&i&&s){if(a.sublayers)a.sublayers.forEach(g);else if(a.popupEnabled){const l=k(a,F(E({},n),{defaultPopupTemplateEnabled:!1}));u(l)&&h.unshift({sublayer:a,popupTemplate:l})}}},V=y.sublayers.toArray().reverse().map(g);await Promise.all(V);const M=h.map(async({sublayer:a,popupTemplate:i})=>{await a.load().catch(()=>{});const s=a.createQuery(),l=u(n)?n.event:null,f=R({renderer:a.renderer,event:l}),w=this.createFetchPopupFeaturesQueryGeometry(t,f);if(s.geometry=w,s.outFields=await U(a,i),this.layer.type==="map-image"&&"floors"in this.view){var v,x;const O=(v=this.view)==null||(x=v.floors)==null?void 0:x.clone(),m=z(O,a);u(m)&&(s.where=s.where?`(${s.where}) AND (${m})`:m)}const P=await this._loadArcadeModules(i);return P&&P.arcadeUtils.hasGeometryOperations(i)||(s.maxAllowableOffset=w.width/f),(await a.queryFeatures(s)).features});return(await H(M)).reduce((a,i)=>i.value?[...a,...i.value]:a,[]).filter(a=>a!=null)}canResume(){var t;return!!super.canResume()&&((t=this.timeExtent)==null||!t.isEmpty)}_loadArcadeModules(t){if(t.get("expressionInfos.length")||Array.isArray(t.content)&&t.content.some(n=>n.type==="expression"))return L()}};return o([p()],e.prototype,"exportImageParameters",void 0),o([p({readOnly:!0})],e.prototype,"exportImageVersion",null),o([p()],e.prototype,"layer",void 0),o([p()],e.prototype,"suspended",void 0),o([p(T)],e.prototype,"timeExtent",void 0),e=o([A("esri.views.layers.MapImageLayerView")],e),e};let c=class extends B(N){constructor(){super(...arguments),this.type="map-image-3d"}initialize(){this.updatingHandles.add(()=>this.exportImageVersion,()=>this.updatingHandles.addPromise(this.refreshDebounced()))}createFetchPopupFeaturesQueryGeometry(r,e){return j(r,e,this.view)}getFetchOptions(){return{timeExtent:this.timeExtent}}};c=o([A("esri.views.3d.layers.MapImageLayerView3D")],c);const te=c;export{te as default};
