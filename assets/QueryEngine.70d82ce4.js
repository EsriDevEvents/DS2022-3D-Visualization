var fe=Object.defineProperty,ye=Object.defineProperties;var pe=Object.getOwnPropertyDescriptors;var Z=Object.getOwnPropertySymbols;var de=Object.prototype.hasOwnProperty,me=Object.prototype.propertyIsEnumerable;var V=(a,e,t)=>e in a?fe(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t,H=(a,e)=>{for(var t in e||(e={}))de.call(e,t)&&V(a,t,e[t]);if(Z)for(var t of Z(e))me.call(e,t)&&V(a,t,e[t]);return a},J=(a,e)=>ye(a,pe(e));import{fN as xe,fO as ge,fP as C,fQ as L,au as W,fR as $,fS as _e,fT as G,fU as Se,b6 as d,fV as M,fW as we,fX as P,fY as Re,aP as oe,fZ as Qe,f_ as Ie,ei as Fe,b5 as X,a2 as Y,f$ as O,g0 as Ee,b_ as R,g1 as Q,g2 as I,g3 as g,ev as $e,ew as Ge,g4 as be,g5 as b,cl as B,g6 as ve,g7 as K,c0 as ee,ca as te,_ as q,V as se,b3 as ie,g8 as Pe,f7 as re,g9 as Ce,bB as Ae,by as ke,ga as E,gb as Te,gc as ze,gd as Oe}from"./vendor.96994164.js";function Be(a){return a==="mesh"?xe:ge(a)}function le(a,e){return a?e?4:3:e?3:2}function qe(a,e,t,s){return ce(a,e,t,s.coords[0],s.coords[1])}function je(a,e,t,s,i,r){const u=le(i,r),{coords:o,lengths:n}=s;if(!n)return!1;for(let l=0,c=0;l<n.length;l++,c+=u)if(!ce(a,e,t,o[c],o[c+1]))return!1;return!0}function ce(a,e,t,s,i){if(!a)return!1;const r=le(e,t),{coords:u,lengths:o}=a;let n=!1,l=0;for(const c of o)n=Me(n,u,r,l,c,s,i),l+=c*r;return n}function Me(a,e,t,s,i,r,u){let o=a,n=s;for(let l=s,c=s+i*t;l<c;l+=t){n=l+t,n===c&&(n=s);const h=e[l],f=e[l+1],m=e[n],y=e[n+1];(f<u&&y>=u||y<u&&f>=u)&&h+(u-f)/(y-f)*(m-h)<r&&(o=!o)}return o}const j="feature-store:unsupported-query",Ne={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},N={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function Ue(a){return N.spatialRelationship[a]===!0}function De(a){return N.queryGeometry[we(a)]===!0}function Ze(a){return N.layerGeometry[a]===!0}function Ve(){return import("./geometryEngineJSON.1e50cea4.js")}function ae(a,e,t,s,i){if(C(e)&&t==="esriGeometryPoint"&&(a==="esriSpatialRelIntersects"||a==="esriSpatialRelContains")){const r=L(new W,e,!1,!1);return Promise.resolve(u=>qe(r,!1,!1,u))}if(C(e)&&t==="esriGeometryMultipoint"){const r=L(new W,e,!1,!1);if(a==="esriSpatialRelContains")return Promise.resolve(u=>je(r,!1,!1,u,s,i))}if($(e)&&t==="esriGeometryPoint"&&(a==="esriSpatialRelIntersects"||a==="esriSpatialRelContains"))return Promise.resolve(r=>_e(e,G(t,s,i,r)));if($(e)&&t==="esriGeometryMultipoint"&&a==="esriSpatialRelContains")return Promise.resolve(r=>Se(e,G(t,s,i,r)));if($(e)&&a==="esriSpatialRelIntersects"){const r=Be(t);return Promise.resolve(u=>r(e,G(t,s,i,u)))}return Ve().then(r=>{const u=r[Ne[a]].bind(null,e.spatialReference,e);return o=>u(G(t,s,i,o))})}async function ne(a,e,t){const{spatialRel:s,geometry:i}=a;if(i){if(!Ue(s))throw new d(j,"Unsupported query spatial relationship",{query:a});if(M(i.spatialReference)&&M(t)){if(!De(i))throw new d(j,"Unsupported query geometry type",{query:a});if(!Ze(e))throw new d(j,"Unsupported layer geometry type",{query:a});if(a.outSR)return P(a.geometry&&a.geometry.spatialReference,a.outSR)}}}function ue(a){if($(a))return!0;if(C(a)){for(const e of a.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}function He(a){return a.every(e=>e.statisticType!=="exceedslimit")}const _="feature-store:unsupported-query",v=new Set,Je=new Re(2e6);let Le=0;class Ke{constructor(e){this.capabilities={query:Qe},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",()=>this.clearCache()),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new Ie(Le+++"$$",Je)),this.fieldsIndex=new Fe(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=X(this._frameTask),this.clearCache(),Y(this._geometryQueryCache),this._changeHandle=X(this._changeHandle),Y(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:O(this.spatialReference)}:null}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=Ee(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e={},t){let s,i=R(e);try{i=await this._schedule(()=>Q(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t)}catch(r){if(r!==I)throw r;s=new g([],null,this)}return s.createQueryResponse(i)}async executeQueryForCount(e={},t){let s=R(e);s.returnGeometry=!1,s.returnCentroid=!1,s.outSR=null;try{s=await this._schedule(()=>Q(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t);let i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t);return i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t),i.createQueryResponseForCount(s)}catch(i){if(i!==I)throw i;return 0}}async executeQueryForExtent(e={},t){let s,i=R(e);const r=i.outSR;try{i=await this._schedule(()=>Q(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),i.returnGeometry=!0,i.returnCentroid=!1,i.outSR=null,s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t);const u=s.size;if(!u)return{count:u,extent:null};$e(x,Ge),this.featureStore.forEachBounds(s.items,l=>be(x,l),We);const o={xmin:x[0],ymin:x[1],xmax:x[3],ymax:x[4],spatialReference:O(this.spatialReference)};this.hasZ&&isFinite(x[2])&&isFinite(x[5])&&(o.zmin=x[2],o.zmax=x[5]);const n=b(o,s.spatialReference,r);if(n.spatialReference=O(r||this.spatialReference),n.xmax-n.xmin==0){const l=B(n.spatialReference);n.xmin-=l,n.xmax+=l}if(n.ymax-n.ymin==0){const l=B(n.spatialReference);n.ymin-=l,n.ymax+=l}if(this.hasZ&&n.zmin!=null&&n.zmax!=null&&n.zmax-n.zmin==0){const l=B(n.spatialReference);n.zmin-=l,n.zmax+=l}return{count:u,extent:n}}catch(u){if(u===I)return{count:0,extent:null};throw u}}async executeQueryForIds(e={},t){return this.executeQueryForIdSet(e,t).then(s=>Array.from(s))}async executeQueryForIdSet(e={},t){let s,i=R(e);i.returnGeometry=!1,i.returnCentroid=!1,i.outSR=null;try{i=await this._schedule(()=>Q(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t);const r=s.items,u=new Set;return await this._reschedule(()=>{for(const o of r)u.add(s.featureAdapter.getObjectId(o))},t),u}catch(r){if(r===I)return new Set;throw r}}async executeQueryForSnapping(e,t){const{point:s,distance:i,types:r}=e;if(r===ve.NONE)return{candidates:[]};const u=await this._reschedule(()=>this._checkQuerySupport(e.query),t),o=!K(s.spatialReference,this.spatialReference);o&&await P(s.spatialReference,this.spatialReference);const n=typeof i=="number"?i:i.x,l=typeof i=="number"?i:i.y,c={xmin:s.x-n,xmax:s.x+n,ymin:s.y-l,ymax:s.y+l,spatialReference:s.spatialReference},h=o?b(c,this.spatialReference):c;if(!h)return{candidates:[]};const f=(await ee(te(s),null,{signal:t}))[0],m=(await ee(te(h),null,{signal:t}))[0];if(q(f)||q(m))return{candidates:[]};let y=new g(this._searchFeatures(this._getQueryBBoxes(m.toJSON())),null,this);y=await this._reschedule(()=>y.executeObjectIdsQuery(u),t),y=await this._reschedule(()=>y.executeTimeQuery(u),t),y=await this._reschedule(()=>y.executeAttributesQuery(u),t);const w=f.toJSON(),A=o?b(w,this.spatialReference):w,k=o?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:i;return y.createSnappingResponse(J(H({},e),{point:A,distance:k}),s.spatialReference)}async executeQueryForLatestObservations(e={},t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new d(_,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});let s,i=R(e);try{i=await this._schedule(()=>Q(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t),s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t),s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t),s=await this._reschedule(()=>s.filterLatest(),t)}catch(r){if(r!==I)throw r;s=new g([],null,this)}return s.createQueryResponse(i)}async executeQueryForSummaryStatistics(e={},t,s){const{field:i,normalizationField:r,valueExpression:u}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:u},s)).createSummaryStatisticsResponse(e,t)}async executeQueryForUniqueValues(e={},t,s){const{field:i,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:i,valueExpression:r},s)).createUniqueValuesResponse(e,t)}async executeQueryForClassBreaks(e={},t,s){const{field:i,normalizationField:r,valueExpression:u}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:u},s)).createClassBreaksResponse(e,t)}async executeQueryForHistogram(e={},t,s){const{field:i,normalizationField:r,valueExpression:u}=t;return(await this._getQueryEngineResultForStats(e,{field:i,normalizationField:r,valueExpression:u},s)).createHistogramResponse(e,t)}async _schedule(e,t){return se(this._frameTask)?this._frameTask.schedule(e,t):e(ie)}async _reschedule(e,t){return se(this._frameTask)?this._frameTask.reschedule(e,t):e(ie)}_getAll(){if(!this._allItems){const e=[];this.featureStore.forEach(t=>e.push(t)),this._allItems=new g(e,null,this)}return this._allItems}async _executeGeometryQuery(e,t){const{geometry:s,outSR:i,spatialRel:r,returnGeometry:u,returnCentroid:o}=e,n=this.featureStore.featureSpatialReference,l=s&&n&&n!==s.spatialReference?b(s,n):s,c=u||o,h=M(i)&&!K(this.spatialReference,i),f=this._geometryQueryCache?h&&c?JSON.stringify({originalFilterGeometry:s,spatialRelationship:r,outSpatialReference:i}):JSON.stringify({originalFilterGeometry:s,spatialRelationship:r}):null;if(f){const p=this._geometryQueryCache.get(f);if(!Pe(p))return p}const m=async p=>{if(h&&c){const S=await p.project(i);return f&&this._geometryQueryCache.put(f,S,S.size||1),S}return f&&this._geometryQueryCache.put(f,p,p.size||1),p};if(!l)return m(this._getAll());const y=this.featureAdapter;if(r==="esriSpatialRelDisjoint"){const p=this._searchFeatures(this._getQueryBBoxes(s));if(!p.length)return m(this._getAll());let S,U;const T=new Set;for(const F of p)T.add(y.getObjectId(F));await this._reschedule(()=>{let F=0;S=new Array(T.size),this.featureStore.forEach(z=>S[F++]=z),U=T},t);const he=await this._reschedule(async()=>{const F=await ae(r,l,this.geometryType,this.hasZ,this.hasM),z=D=>!U.has(y.getObjectId(D))||F(y.getGeometry(D));return new g(await this._runSpatialFilter(S,z,t),s,this)},t);return m(he)}const w=this._searchFeatures(this._getQueryBBoxes(s));if(!w.length){const p=new g([],s,this);return f&&this._geometryQueryCache.put(f,p,p.size||1),p}if(this._canExecuteSoloPass(l,e))return m(new g(w,s,this));const A=await ae(r,l,this.geometryType,this.hasZ,this.hasM),k=await this._runSpatialFilter(w,p=>A(y.getGeometry(p)),t);return m(new g(k,s,this))}async _runSpatialFilter(e,t,s){if(!t)return e;if(q(this._frameTask))return e.filter(o=>t(o));let i=0;const r=new Array,u=async o=>{for(;i<e.length;){const n=e[i++];t(n)&&(r.push(n),o.madeProgress()),o.done&&await this._reschedule(l=>u(l),s)}};return this._reschedule(o=>u(o),s).then(()=>r)}_canExecuteSoloPass(e,t){const{geometryType:s}=this,{spatialRel:i}=t;return ue(e)&&(i==="esriSpatialRelEnvelopeIntersects"||s==="esriGeometryPoint"&&(i==="esriSpatialRelIntersects"||i==="esriSpatialRelContains"||i==="esriSpatialRelWithin"))}_getQueryBBoxes(e){if(ue(e)){if($(e))return[re(e.xmin,e.ymin,e.xmax,e.ymax)];if(C(e))return e.rings.map(t=>re(Math.min(t[0][0],t[2][0]),Math.min(t[0][1],t[2][1]),Math.max(t[0][0],t[2][0]),Math.max(t[0][1],t[2][1])))}return[Ce(Ae(),e)]}_searchFeatures(e){for(const i of e)this.featureStore.forEachInBounds(i,r=>{v.add(r)});const t=new Array(v.size);let s=0;return v.forEach(i=>t[s++]=i),v.clear(),t}async _checkStatisticsSupport(e,t){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new d(_,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsParamsSupport(t),ne(e,this.geometryType,this.spatialReference),P(this.spatialReference,e.outSR)]).then(()=>e)}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:s}=await ke();t=s.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new d(_,"params should have at least a field or valueExpression",{params:e});E(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new d(_,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),ne(e,this.geometryType,this.spatialReference),P(this.spatialReference,e.outSR)]).then(()=>e)}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:s,returnDistinctValues:i,outStatistics:r}=e,u=r?r.map(o=>o.outStatisticFieldName&&o.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if(s&&s.length>0){const o=" asc",n=" desc",l=s.map(c=>{const h=c.toLowerCase();return h.indexOf(o)>-1?h.split(o)[0]:h.indexOf(n)>-1?h.split(n)[0]:c}).filter(c=>u.indexOf(c)===-1);E(this.fieldsIndex,l,"orderByFields contains missing fields")}if(t&&t.length>0)E(this.fieldsIndex,t,"outFields contains missing fields");else if(i)throw new d(_,"outFields should be specified for returnDistinctValues",{query:e});Te(this.fieldsIndex,e.where)}async _checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:s,having:i}=e,r=s&&s.length,u=t&&t.length;if(i){if(!r||!u)throw new d(_,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});ze(this.fieldsIndex,i,t)}if(u){if(!He(t))return;const o=t.map(n=>n.onStatisticField).filter(Boolean);E(this.fieldsIndex,o,"onStatisticFields contains missing fields"),r&&E(this.fieldsIndex,s,"groupByFieldsForStatistics contains missing fields");for(const n of t){const{onStatisticField:l,statisticType:c}=n;if((c==="percentile_disc"||c==="percentile_cont")&&"statisticParameters"in n){const{statisticParameters:h}=n;if(!h)throw new d(_,"statisticParamters should be set for percentile type",{definition:n,query:e})}else if(c!=="count"&&l&&Oe(l,this.fieldsIndex))throw new d(_,"outStatistics contains non-numeric fields",{definition:n,query:e})}}}async _getQueryEngineResultForStats(e={},t,s){let i;e=R(e);try{e=await this._schedule(()=>Q(e,this.definitionExpression,this.spatialReference),s),e=await this._reschedule(()=>this._checkStatisticsSupport(e,t),s),i=await this._reschedule(()=>this._executeGeometryQuery(e,s),s),i=await this._reschedule(()=>i.executeAggregateIdsQuery(e),s),i=await this._reschedule(()=>i.executeObjectIdsQuery(e),s),i=await this._reschedule(()=>i.executeTimeQuery(e),s),i=await this._reschedule(()=>i.executeAttributesQuery(e),s)}catch(r){if(r!==I)throw r;i=new g([],null,this)}return i}}const We=oe(),x=oe();export{Ke as V,ae as v};
